package evalg.doors.gen;

import org.nlogo.headless.HeadlessWorkspace;
import org.nlogo.app.App;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.Scanner;
import java.util.ArrayList;


public class MainClass {
	
	public static int getGenIndex(double r, int max) {
		/*
		 * Lo hago como funcion, para encapsular, y así dejar más 
		 * limpio el codigo y hacerlo más escalable.
		 * */
		return (int) Math.floor(max*r);
	}
	
	public static ArrayList<Genome> runSimulation(HeadlessWorkspace wkspc, String buildingPath, String path, ArrayList<Genome> generation, int gen_idx) {
		ArrayList<Genome> best_worst = new ArrayList<>();
		int subject_idx = 0;
		for(Genome subject:generation) {
			String doorsFilePath = path+"generation_"+gen_idx+"/subj_"+subject_idx+"/doors.txt";
			try {
				PrintWriter doorsFile = new PrintWriter(doorsFilePath, "UTF-8");
				for (int i = 0; i < subject.getSize(); i++) {
					Gen gen = subject.getGen(i);
					doorsFile.println(gen.x+" "+gen.y);
				}
				doorsFile.close();
				//set arrays
				wkspc.command("set patch-data []");
				wkspc.command("set door-data []");
				//clear prev data
				wkspc.clearTurtles();
				wkspc.command("reset-ticks");
				//open building file
				wkspc.command("file-open "+buildingPath);
				//read building file
				wkspc.command("while [ not file-at-end? ] [ set patch-data sentence patch-data (list (list file-read file-read file-read)) ]");
				//close building file
				wkspc.command("file-close");
				//open doors file
				wkspc.command("file-open "+doorsFilePath);
				//read doors file
				wkspc.command("while [ not file-at-end? ] [ set door-data sentence door-data (list (list file-read file-read)) ]");
				//close doors file
				wkspc.command("file-close");
				//determinar poblacion
				//generar poblacion
				
				
				//correr sym -> implementar en netlogo
				subject.setFitness((Integer) wkspc.report("ticks"));
				if(best_worst.size() < 1) {
					//al comienzo el primer sujeto es el mejor y el peor
					best_worst.add(subject);
					best_worst.add(subject);
				}else{
					best_worst.set(0, subject.greater(best_worst.get(0)));
					best_worst.set(1, subject.lesser(best_worst.get(1)));
				}
			}catch (UnsupportedEncodingException uee) {
				uee.printStackTrace();
			}catch (FileNotFoundException fnfe) {
				fnfe.printStackTrace();
			}
		}
        return best_worst;
	}
	
	public static boolean run_netlogo(String escapeFileString) {
		boolean success=true;
		String[] argv= {};
		App.main(argv);
		try {
	      java.awt.EventQueue.invokeAndWait(
			new Runnable() {
			  public void run() {
			    try {
			    	App.app().open(escapeFileString);
			    }
			    catch(java.io.IOException ex) {
			      ex.printStackTrace();
			    }}});
        }
        catch(Exception ex) {
            ex.printStackTrace();
        }
		return success;
	}
	
	public static long calcVariabilidad(ArrayList<Genome> generation) {
		return 0;
	}

	public static void main(String[] args) {
		String wkspc = new File("").getAbsolutePath()+"/src/";
		String [] buildingFiles = {"conference.plan","office.plan","office.plan"};
		int generation_size = 20;
		int genome_size = 5;
		
		HeadlessWorkspace NLworkspace = HeadlessWorkspace.newInstance();
		try {
            NLworkspace.open(wkspc+"program/escape4_v6.nlogo");
		
			for(String buildingFile: buildingFiles) {
				//la idea es: por cada archivo, parsear los puntos y ponerlos en contenedores distintos
				ArrayList<Gen> outside = new ArrayList<>();
				ArrayList<Gen> inside = new ArrayList<>();
				ArrayList<Gen> wall = new ArrayList<>();
				String buildingPath = wkspc+"buildings/"+buildingFile;
				File buildingPlan = new File(buildingPath);
				try {
					Scanner reader = new Scanner(buildingPlan);
					while(reader.hasNextLine()) {
						String [] line = reader.nextLine().split(" ");
						switch (Integer.parseInt(line[2])) {
						case 0:
							inside.add(new Gen(Integer.parseInt(line[0]),Integer.parseInt(line[1])));
							break;
						case 2:
							outside.add(new Gen(Integer.parseInt(line[0]),Integer.parseInt(line[1])));
							break;
						case 64:
							wall.add(new Gen(Integer.parseInt(line[0]),Integer.parseInt(line[1])));
							break;
						}
					}
					reader.close();
					//luego, generar 5 numeros aleatorios Ri (i=1..5), tal que 
					// si |wall| = Nw, y f(x) : Dom(R)->[0,Nw]; f(x) = mx+b, y R e [0,1]
					// plt, f(x) = Nw*x
					ArrayList<ArrayList<Genome>> generations = new ArrayList<>();
					generations.add(new ArrayList<>());
					for (int i = 0; i < generation_size; i++) {
						Genome genome = new Genome(genome_size);
						for (int j = 0; j < genome_size; j++) {
							int gen_idx = getGenIndex(Math.random(),wall.size());
							while (genome.exist(gen_idx)) gen_idx = getGenIndex(Math.random(),wall.size());
							genome.addGen(wall.get(gen_idx), gen_idx);
						}
						generations.get(0).add(genome);
					}
					int gen_idx = 0;
					double var_delta = 0; //some number;
					do {
						System.out.println("Simulando "+gen_idx);
						runSimulation(NLworkspace, buildingPath, wkspc, generations.get(gen_idx), gen_idx);
						//select best
						//select worst
						//generate random
						//select for mutation
						//mutate
						//select for reproduction
						//reproduce
					}while(calcVariabilidad(generations.get(gen_idx++)) >= var_delta);
					
				}catch(FileNotFoundException e) {
					e.printStackTrace();
				}
			}
			NLworkspace.dispose();
		}catch(Exception ex) {
            ex.printStackTrace();
        }
	}
	
	public static ArrayList<Genome> selectForMutation(ArrayList<Genome> generation, int k){
		//para este proceso se utilizrá la metodología SUS, combinada con ranking
		//Se supone que el genoma viene reordenado en forma ascendente, donde 0 es el peor y n el mejor.
		//el largo de la lista final esta dado por (k^2+k)/2
		ArrayList<Genome> forMutation =  new ArrayList<>();
		//se genera una lista con 1 0, 2 1, 3 2, etc
		ArrayList<Integer> roulette = new ArrayList<>();
		for (int i = 1; i <= generation.size(); i++) {
			for (int j = 0; j < (i*i+i)/2; j++) {
				roulette.add(i);
			}
		}
		//se hacer "girar" -> se determina el pivote
		int pivot = (int) Math.random()*roulette.size();
		//mover roullete y selecionar índices segun 'k'
		roulette.addAll(roulette.subList(0,pivot));
		roulette.subList(0,pivot).clear();
		//seleccionar k valores equidistantes
		//y agregar a  'forMutation
		for	(int i = 0; i < roulette.size(); i += (int) roulette.size()/k) {
			forMutation.add(generation.get(roulette.get(i)-1));
		}
		return forMutation;
	}
	
	public static ArrayList<Genome> selectForReproduction(ArrayList<Genome> generation, int k, int n){
		//para este proceso se utilizará la metodología de torneo 
		//donde k es el tamaño de los grupos y n la cantidad de individuos a generar
		
		return new ArrayList<Genome>(); 
	}

}
